//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#ifndef USER_H
#define USER_H
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#include "Item.h"
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#define CHAR_SET_SIZE			13
// ----
#define INVENTORY_SIZE			108
#define WAREHOUSE_SIZE			120
// ----
#define CS_CLASS				0
// ----
#define CS_WEAPON1_TYPE			1
#define CS_WEAPON2_TYPE			2
// ----
#define CS_WEAPON1_DATA			12
#define CS_WEAPON2_DATA			13
// ----
#define CS_HELMET1				13
#define CS_HELMET2				9
#define CS_HELMET3				3
// ----
#define CS_ARMOR1				14
#define CS_ARMOR2				9
#define CS_ARMOR3				3
// ----
#define CS_PANTS1				14
#define CS_PANTS2				9
#define CS_PANTS3				4
// ----
#define CS_GLOVES1				15
#define CS_GLOVES2				9
#define CS_GLOVES3				4
// ----
#define CS_BOOTS1				15
#define CS_BOOTS2				9
#define CS_BOOTS3				5
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#define CS_GET_CLASS(x)		((((x)>>4)<<5)&(0xE0))
#define CS_GET_CHANGEUP(x)	(((x)&0x07))
#define CS_SET_CLASS(x)		(((x) << 5) & 0xE0)
#define CS_SET_CHANGEUP(x)	(((x) << 4) & 0x10)
// ----
#define CS_SET_HELMET1(x) ( ((x) & 0x1E0) >> 5 )
#define CS_SET_HELMET2(x) ( ((x) & 0x10 ) << 3 )
#define CS_SET_HELMET3(x) ( ((x) & 0x0F ) << 4 )
// ----
#define CS_SET_ARMOR1(x) ( ((x) & 0x1E0) >> 1 )
#define CS_SET_ARMOR2(x) ( ((x) & 0x10 ) << 2 )
#define CS_SET_ARMOR3(x) ( ((x) & 0x0F )      )
// ----
#define CS_SET_PANTS1(x) ( ((x) & 0x1E0) >> 5 )
#define CS_SET_PANTS2(x) ( ((x) & 0x10 ) << 1 )
#define CS_SET_PANTS3(x) ( ((x) & 0x0F ) << 4 )
// ----
#define CS_SET_GLOVES1(x) ( ((x) & 0x1E0) >> 1 )
#define CS_SET_GLOVES2(x) ( ((x) & 0x10 )      )
#define CS_SET_GLOVES3(x) ( ((x) & 0x0F )      )
// ----
#define CS_SET_BOOTS1(x) ( ((x) & 0x1E0) >> 5 )
#define CS_SET_BOOTS2(x) ( ((x) & 0x10 ) >> 1 )
#define CS_SET_BOOTS3(x) ( ((x) & 0x0F ) << 4 )
// ----
#define CS_SET_WING1(x)  ( ((x) & 0x03 ) << 2 )
#define CS_SET_HELPER(x) ( ((x) & 0x03 )      )
// ----
#define CS_SET_SMALLLEVEL_RH(x)		( (x)       )
#define CS_SET_SMALLLEVEL_LH(x)		( (x) << 3  ) 
#define CS_SET_SMALLLEVEL_HELMET(x)	( (x) << 6  )
#define CS_SET_SMALLLEVEL_ARMOR(x)	( (x) << 9  )
#define CS_SET_SMALLLEVEL_PANTS(x)	( (x) << 12 )
#define CS_SET_SMALLLEVEL_GLOVES(x)	( (x) << 15 )
#define CS_SET_SMALLLEVEL_BOOTS(x)	( (x) << 18 )
// ----
#define CS_SET_SMALLLEVEL1(x)		( ((x) >> 16) & 0xFF )
#define CS_SET_SMALLLEVEL2(x)		( ((x) >> 8 ) & 0xFF )
#define CS_SET_SMALLLEVEL3(x)		((x) & 0xFF )
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#define MAX_USER_GUILD			80
#define MAX_ACCOUNT_LEN			10
#define MAX_MAP_RANGE(x) (((x)<0)?false:((x)>50-1)?false:true)
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

enum OBJECT_TYPE
{
	OBJ_EMPTY	=	-1,
	OBJ_MONSTER =	2,
	OBJ_USER	=	1,
	OBJ_NPC		=	3,
};
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

enum PLAYER_STATUS
{
	PLAYER_EMPTY,
	PLAYER_CONNECTED,
	PLAYER_LOGGED,
	PLAYER_PLAYING,
};
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

struct tagInterfaceState
{
	BYTE use;
	BYTE state;
	BYTE type;
};

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

struct _PER_IO_CONTEXT // 0x2f10
{
    _OVERLAPPED Overlapped; // +0x0(0x14)
    _WSABUF wsabuf; // +0x14(0x8)
    CHAR Buffer[0x1770]; // +0x1c(0x1770)
    CHAR BufferSecond[0x1770]; // +0x178c(0x1770)
    int nSecondOfs; // +0x2efc(0x4)
    int nTotalBytes; // +0x2f00(0x4)
    int nSentBytes; // +0x2f04(0x4)
    int IOOperation; // +0x2f08(0x4)
    int nWaitIO; // +0x2f0c(0x4)
};

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
typedef struct _PER_SOCKET_CONTEXT
{
	SOCKET			m_socket;
	int				nIndex;
	_PER_IO_CONTEXT	IOContext[2];
	long			dwIOCount;
} PER_SOCKET_CONTEXT, *LPPER_SOCKET_CONTEXT;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

struct _GUILD_INFO_STRUCT // 0x73c
{
	int Number; // +0x0(0x4)
    CHAR Name[0x9]; // +0x4(0x9)
    UCHAR Mark[0x20]; // +0xd(0x20)
    UCHAR Count; // +0x2d(0x1)
    UCHAR TotalCount; // +0x2e(0x1)
    CHAR Names[0xb][0x50]; // +0x2f(0x370)
    SHORT Index[0x50]; // +0x3a0(0xa0)
    UCHAR Use[0x50]; // +0x440(0x50)
    CHAR pServer[0x50]; // +0x490(0x50)
    CHAR TargetGuildName[0x9]; // +0x4e0(0x9)
    SHORT TargetIndex[0x50]; // +0x4ea(0xa0)
    _GUILD_INFO_STRUCT* lpTargetGuildNode; // +0x58c(0x4)
    UCHAR WarDeclareState; // +0x590(0x1)
    UCHAR WarState; // +0x591(0x1)
    UCHAR WarType; // +0x592(0x1)
    UCHAR BattleGroundIndex; // +0x593(0x1)
    UCHAR BattleTeamCode; // +0x594(0x1)
    UCHAR PlayScore; // +0x595(0x1)
    int TotalScore; // +0x598(0x4)
    CHAR Notice[0x3c]; // +0x59c(0x3c)
    int GuildStatus[0x50]; // +0x5d8(0x140)
    UCHAR btGuildType; // +0x718(0x1)
    int iGuildUnion; // +0x71c(0x4)
    int iGuildRival; // +0x720(0x4)
    int iTimeStamp; // +0x724(0x4)
    CHAR szGuildRivalName[0x9]; // +0x728(0x9)
    _GUILD_INFO_STRUCT* back; // +0x734(0x4)
    _GUILD_INFO_STRUCT* next; // +0x738(0x4)
};
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#ifdef GS_99_60T
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

struct OBJECTSTRUCT // 0x1570
{
    int m_Index; // +0x0(0x4)
    int Connected; // +0x4(0x4)
    CHAR LoginMsgSnd; // +0x8(0x1)
    CHAR LoginMsgCount; // +0x9(0x1)
    CHAR CloseCount; // +0xa(0x1)
    CHAR CloseType; // +0xb(0x1)
    struct _PER_SOCKET_CONTEXT* PerSocketContext; // +0xc(0x4)
    unsigned int m_socket; // +0x10(0x4)
    CHAR Ip_addr[0x10]; // +0x14(0x10)
    int UserNumber; // +0x24(0x4)
    int DBNumber; // +0x28(0x4)
    UCHAR Magumsa; // +0x2c(0x1)
    ULONG AutoSaveTime; // +0x30(0x4)
    ULONG ConnectCheckTime; // +0x34(0x4)
    ULONG CheckTick; // +0x38(0x4)
    UCHAR CheckSpeedHack; // +0x3c(0x1)
    ULONG CheckTick2; // +0x40(0x4)
    UCHAR CheckTickCount; // +0x44(0x1)
    ULONG SaveTimeForStatics; // +0x48(0x4)
    int iPingTime; // +0x4c(0x4)
    UCHAR m_TimeCount; // +0x50(0x1)
    ULONG m_dwPKTimer; // +0x54(0x4)
    SHORT CheckSumTableNum; // +0x58(0x2)
    ULONG CheckSumTime; // +0x5c(0x4)
    USHORT Type; // +0x60(0x2)
    UCHAR Live; // +0x62(0x1)
    CHAR CharacterPos; // +0x63(0x1)
    CHAR AccountID[0xb]; // +0x64(0xb)
    CHAR Name[0xb]; // +0x6f(0xb)
    CHAR LastJoominNumber[0xe]; // +0x7a(0xe)
	SHORT Filter;SHORT Filter2;SHORT Filter3;
    /*//ComboSkillData comboSkill;//*/char comboSkill[0xc-2]; // +0x8c(0xc) // struct ComboSkillData comboSkill
    USHORT Class; // +0x98(0x2)
    UCHAR DbClass; // +0x9a(0x1)
    UCHAR ChangeUP; // +0x9b(0x1)
    SHORT Level; // +0x9c(0x2)
    int LevelUpPoint; // +0xa0(0x4)
    ULONG Experience; // +0xa4(0x4)
    ULONG NextExp; // +0xa8(0x4)
    int Money; // +0xac(0x4)
    SHORT Strength; // +0xb0(0x2)
    SHORT Dexterity; // +0xb2(0x2)
    SHORT Vitality; // +0xb4(0x2)
    SHORT Energy; // +0xb6(0x2)
    float Life; // +0xb8(0x4)
    float MaxLife; // +0xbc(0x4)
    float FillLife; // +0xc0(0x4)
    float FillLifeMax; // +0xc4(0x4)
    float Mana; // +0xc8(0x4)
    float MaxMana; // +0xcc(0x4)
    USHORT Leadership; // +0xd0(0x2)
    USHORT AddLeadership; // +0xd2(0x2)
    USHORT ChatLitmitTime; // +0xd4(0x2)
    UCHAR ChatLimitTimeSec; // +0xd6(0x1)
    UCHAR FillLifeCount; // +0xd7(0x1)
    SHORT AddStrength; // +0xd8(0x2)
    SHORT AddDexterity; // +0xda(0x2)
    SHORT AddVitality; // +0xdc(0x2)
    SHORT AddEnergy; // +0xde(0x2)
    int BP; // +0xe0(0x4)
    int MaxBP; // +0xe4(0x4)
    int AddBP; // +0xe8(0x4)
    float VitalityToLife; // +0xec(0x4)
    float EnergyToMana; // +0xf0(0x4)
    CHAR m_PK_Count; // +0xf4(0x1)
    CHAR m_PK_Level; // +0xf5(0x1)
    int m_PK_Time; // +0xf8(0x4)
    SHORT X; // +0xfc(0x2)
    SHORT Y; // +0xfe(0x2)
    UCHAR Dir; // +0x100(0x1)
    UCHAR MapNumber; // +0x101(0x1)
    int AddLife; // +0x104(0x4)
    int AddMana; // +0x108(0x4)
	BYTE  DamageMinus;	// 134
	BYTE  DamageReflect;	// 135
	short MonsterDieGetMoney;	// 136
	BYTE  MonsterDieGetLife;	// 138
	BYTE  MonsterDieGetMana;	// 139
	BYTE  StartX;	// 13A
	BYTE  StartY;	// 13B
	short m_OldX;	// 13C
	short m_OldY;	// 13E
	short TX;	// 140
	short TY;	// 142
	short MTX;	// 144
	short MTY;	// 146
	int   PathCount;	// 148
	int   PathCur;	// 14C
	char  PathStartEnd;	// 150
	short PathOri[15];	// 152
	short PathX[15];	// 170
	short PathY[15];	// 18E
	char  PathDir[15];	// 1AC
	DWORD PathTime; // 1BC
	BYTE  m_MoveGateNumber;	// 1C0
	DWORD Authority;	// 1C4
	DWORD AuthorityCode;	// 1C8
    ULONG Penalty; // +0x1a4(0x4)
    UCHAR m_cAccountItemBlock; // +0x1a8(0x1)
    LPVOID m_ActState; // +0x1ac(0x4)	// struct tagActionState m_ActState;
    UCHAR m_ActionNumber; // +0x1b0(0x1)
    ULONG m_State; // +0x1b4(0x4)
    CHAR m_StateSub; // +0x1b8(0x1)
    UCHAR m_Rest; // +0x1b9(0x1)
    CHAR m_ViewState; // +0x1ba(0x1)
    int m_ViewSkillState; // +0x1bc(0x4)
    ULONG m_LastMoveTime; // +0x1c0(0x4)
    ULONG m_LastAttackTime; // +0x1c4(0x4)
    UCHAR m_FriendServerOnline; // +0x1c8(0x1)
    int m_DetectSpeedHackTime; // +0x1cc(0x4)
    ULONG m_SumLastAttackTime; // +0x1d0(0x4)
    ULONG m_DetectCount; // +0x1d4(0x4)
    int m_DetectedHackKickCount; // +0x1d8(0x4)
    int m_SpeedHackPenalty; // +0x1dc(0x4)
    UCHAR m_AttackSpeedHackDetectedCount; // +0x1e0(0x1)
    ULONG m_PacketCheckTime; // +0x1e4(0x4)
    UCHAR m_ShopTime; // +0x1e8(0x1)
    ULONG m_TotalAttackTime; // +0x1ec(0x4)
    int m_TotalAttackCount; // +0x1f0(0x4)
    ULONG TeleportTime; // +0x1f4(0x4)
    CHAR Teleport; // +0x1f8(0x1)
    CHAR KillerType; // +0x1f9(0x1)
    CHAR DieRegen; // +0x1fa(0x1)
    CHAR RegenOk; // +0x1fb(0x1)
    UCHAR RegenMapNumber; // +0x1fc(0x1)
    UCHAR RegenMapX; // +0x1fd(0x1)
    UCHAR RegenMapY; // +0x1fe(0x1)
    ULONG RegenTime; // +0x200(0x4)
    ULONG MaxRegenTime; // +0x204(0x4)
    SHORT m_PosNum; // +0x208(0x2)
    ULONG LifeRefillTimer; // +0x20c(0x4)
    ULONG CurActionTime; // +0x210(0x4)
    ULONG NextActionTime; // +0x214(0x4)
    ULONG DelayActionTime; // +0x218(0x4)
    CHAR DelayLevel; // +0x21c(0x1)
    CHAR m_PoisonType; // +0x21d(0x1)
    CHAR m_IceType; // +0x21e(0x1)
    CHAR m_PoisonBeattackCount; // +0x21f(0x1)
    CHAR m_ColdBeattackCount; // +0x220(0x1)
    CHAR m_ImmuneToMagicCount; // +0x221(0x1)
    CHAR m_ImmuneToHarmCount; // +0x222(0x1)
    CHAR m_iMonsterBattleDelay; // +0x223(0x1)
    CHAR m_cKalimaGateExist; // +0x224(0x1)
    int m_iKalimaGateIndex; // +0x228(0x4)
    CHAR m_cKalimaGateEnterCount; // +0x22c(0x1)
    struct OBJECTSTRUCT* lpAttackObj; // +0x230(0x4)
    SHORT m_SkillNumber; // +0x234(0x2)
    ULONG m_SkillTime; // +0x238(0x4)
    UCHAR m_bAttackerKilled; // +0x23c(0x1)
    CHAR m_ManaFillCount; // +0x23d(0x1)
    CHAR m_LifeFillCount; // +0x23e(0x1)
    int SelfDefense[0x5]; // +0x240(0x14)
    ULONG SelfDefenseTime[0x5]; // +0x254(0x14)
    ULONG MySelfDefenseTime; // +0x268(0x4)
    CHAR m_Drink; // +0x26c(0x1)
    int m_SkillDefense; // +0x270(0x4)
    CHAR m_SkillDefenseTime; // +0x274(0x1)
    int m_SkillAttack; // +0x278(0x4)
    CHAR m_SkillAttackTime; // +0x27c(0x1)
    int m_SkillAttack2; // +0x280(0x4)
    CHAR m_SkillAttackTime2; // +0x284(0x1)
    int m_SkillAddLife; // +0x288(0x4)
    int m_SkillAddLifeTime; // +0x28c(0x4)
    int m_SkillHarden; // +0x290(0x4)
    int m_SkillHardenTime; // +0x294(0x4)
    int m_SkillMagumReduceDefense; // +0x298(0x4)
    int m_SkillMagumReduceDefenseTime; // +0x29c(0x4)
    int PartyNumber; // +0x2a0(0x4)
    int PartyTargetUser; // +0x2a4(0x4)
    int GuildNumber; // +0x2a8(0x4)
    _GUILD_INFO_STRUCT* lpGuild; // +0x2ac(0x4)
    CHAR GuildName[0xb]; // +0x2b0(0xb)
    int GuildStatus; // +0x2bc(0x4)
    int iGuildUnionTimeStamp; // +0x2c0(0x4)
    int m_RecallMon; // +0x2c4(0x4)
    int m_Change; // +0x2c8(0x4)
    SHORT TargetNumber; // +0x2cc(0x2)
    SHORT TargetShopNumber; // +0x2ce(0x2)
    SHORT ShopNumber; // +0x2d0(0x2)
    SHORT LastAttackerID; // +0x2d2(0x2)
    int m_AttackDamageMin; // +0x2d4(0x4)
    int m_AttackDamageMax; // +0x2d8(0x4)
    int m_MagicDamageMin; // +0x2dc(0x4)
    int m_MagicDamageMax; // +0x2e0(0x4)
    int m_AttackDamageLeft; // +0x2e4(0x4)
    int m_AttackDamageRight; // +0x2e8(0x4)
    int m_AttackDamageMaxLeft; // +0x2ec(0x4)
    int m_AttackDamageMinLeft; // +0x2f0(0x4)
    int m_AttackDamageMaxRight; // +0x2f4(0x4)
    int m_AttackDamageMinRight; // +0x2f8(0x4)
    int m_AttackRating; // +0x2fc(0x4)
    int m_AttackSpeed; // +0x300(0x4)
    int m_MagicSpeed; // +0x304(0x4)
    int m_Defense; // +0x308(0x4)
    int m_MagicDefense; // +0x30c(0x4)
    int m_SuccessfulBlocking; // +0x310(0x4)
    SHORT m_MoveSpeed; // +0x314(0x2)
    SHORT m_MoveRange; // +0x316(0x2)
    SHORT m_AttackRange; // +0x318(0x2)
    SHORT m_AttackType; // +0x31a(0x2)
    SHORT m_ViewRange; // +0x31c(0x2)
    SHORT m_Attribute; // +0x31e(0x2)
    SHORT m_ItemRate; // +0x320(0x2)
    SHORT m_MoneyRate; // +0x322(0x2)
    int m_CriticalDamage; // +0x324(0x4)
    int m_ExcelentDamage; // +0x328(0x4)
    class CMagicInf* m_lpMagicBack; // +0x32c(0x4)
    class CMagicInf* Magic; // +0x330(0x4)
    CHAR MagicCount; // +0x334(0x1)
    UCHAR UseMagicNumber; // +0x335(0x1)
    ULONG UseMagicTime; // +0x338(0x4)
    CHAR UseMagicCount; // +0x33c(0x1)
    SHORT OSAttackSerial; // +0x33e(0x2)
    UCHAR SASCount; // +0x340(0x1)
    ULONG SkillAttackTime; // +0x344(0x4)
    UCHAR CharSet[0xd]; // +0x348(0xd)
    UCHAR m_Resistance[0x7]; // +0x355(0x7)
    UCHAR m_AddResistance[0x7]; // +0x35c(0x7)
    int FrustrumX[0x4]; // +0x364(0x10)
    int FrustrumY[0x4]; // +0x374(0x10)
    char VpPlayer[0x384]; // +0x384(0x384)	// struct VIEWPORT_STRUCT VpPlayer[0x4b];
    char VpPlayer2[0x384]; // +0x708(0x384)	// struct VIEWPORT_PLAYER_STRUCT VpPlayer2[0x4b];
    int VPCount; // +0xa8c(0x4)
    int VPCount2; // +0xa90(0x4)
    char sHD[0x1e0]; // +0xa94(0x1e0)	// struct HITDAMAGE_STRUCT sHD[0x28]; 
    SHORT sHDCount; // +0xc74(0x2)
    struct tagInterfaceState m_IfState; // +0xc78(0x4)	// struct tagInterfaceState m_IfState;
    ULONG m_InterfaceTime; // +0xc7c(0x4)
    CItem * pInventory; // +0xc80(0x4)
    UCHAR* pInventoryMap; // +0xc84(0x4)
    CHAR* pInventoryCount; // +0xc88(0x4)
    CHAR pTransaction; // +0xc8c(0x1)
	CItem* Inventory1; // +0xc90(0x4)
    UCHAR* InventoryMap1; // +0xc94(0x4)
    CHAR InventoryCount1; // +0xc98(0x1)
	CItem* Inventory2; // +0xc9c(0x4)
    UCHAR* InventoryMap2; // +0xca0(0x4)
    CHAR InventoryCount2; // +0xca4(0x1)
    class CItem* Trade; // +0xca8(0x4)
    UCHAR* TradeMap; // +0xcac(0x4)
    int TradeMoney; // +0xcb0(0x4)
    UCHAR TradeOk; // +0xcb4(0x1)
	CItem * pWarehouse; // +0xcb8(0x4)
    UCHAR* pWarehouseMap; // +0xcbc(0x4)
    CHAR WarehouseCount; // +0xcc0(0x1)
    SHORT WarehousePW; // +0xcc2(0x2)
    UCHAR WarehouseLock; // +0xcc4(0x1)
    UCHAR WarehouseUnfailLock; // +0xcc5(0x1)
    int WarehouseMoney; // +0xcc8(0x4)
    int WarehouseSave; // +0xccc(0x4)
    class CItem* pChaosBox; // +0xcd0(0x4)
    UCHAR* pChaosBoxMap; // +0xcd4(0x4)
    int ChaosMoney; // +0xcd8(0x4)
    int ChaosSuccessRate; // +0xcdc(0x4)
    int ChaosLock; // +0xce0(0x4)
    ULONG m_Option; // +0xce4(0x4)
    int m_nEventScore; // +0xce8(0x4)
    int m_nEventExp; // +0xcec(0x4)
    int m_nEventMoney; // +0xcf0(0x4)
    UCHAR m_bDevilSquareIndex; // +0xcf4(0x1)
    UCHAR m_bDevilSquareAuth; // +0xcf5(0x1)
    CHAR m_cBloodCastleIndex; // +0xcf6(0x1)
    CHAR m_cBloodCastleSubIndex; // +0xcf7(0x1)
    int m_iBloodCastleEXP; // +0xcf8(0x4)
    CHAR m_cChaosCastleIndex; // +0xcfc(0x1)
    CHAR m_cChaosCastleSubIndex; // +0xcfd(0x1)
    int m_iChaosCastleBlowTime; // +0xd00(0x4)
    CHAR m_cKillUserCount; // +0xd04(0x1)
    CHAR m_cKillMonsterCount; // +0xd05(0x1)
    int m_iDuelUserReserved; // +0xd08(0x4)
    int m_iDuelUserRequested; // +0xd0c(0x4)
    int m_iDuelUser; // +0xd10(0x4)
    UCHAR m_btDuelScore; // +0xd14(0x1)
    int m_iDuelTickCount; // +0xd18(0x4)
    UCHAR m_bPShopOpen; // +0xd1c(0x1)
    UCHAR m_bPShopTransaction; // +0xd1d(0x1)
    UCHAR m_bPShopItemChange; // +0xd1e(0x1)
    UCHAR m_bPShopRedrawAbs; // +0xd1f(0x1)
    CHAR m_szPShopText[0x24]; // +0xd20(0x24)
    UCHAR m_bPShopWantDeal; // +0xd44(0x1)
    int m_iPShopDealerIndex; // +0xd48(0x4)
    CHAR m_szPShopDealerName[0xa]; // +0xd4c(0xa)
    struct _RTL_CRITICAL_SECTION m_critPShopTrade; // +0xd58(0x18)
    int m_iVpPShopPlayer[0x4b]; // +0xd70(0x12c)
    USHORT m_wVpPShopPlayerCount; // +0xe9c(0x2)
    UCHAR IsInBattleGround; // +0xe9e(0x1)
    UCHAR HaveWeaponInHand; // +0xe9f(0x1)
    SHORT EventChipCount; // +0xea0(0x2)
    int MutoNumber; // +0xea4(0x4)
    int UseEventServer; // +0xea8(0x4)
    UCHAR LoadWareHouseInfo; // +0xeac(0x1)
    int iStoneCount; // +0xeb0(0x4)
    UCHAR m_Quest[0x32]; // +0xeb4(0x32)
    UCHAR m_SendQuestInfo; // +0xee6(0x1)
    int m_SkyBossMonSheildLinkIndex; // +0xee8(0x4)
    int m_SkyBossMonSheild; // +0xeec(0x4)
    int m_SkyBossMonSheildTime; // +0xef0(0x4)
    int m_MaxLifePower; // +0xef4(0x4)
    int m_WizardSkillDefense; // +0xef8(0x4)
    int m_WizardSkillDefenseTime; // +0xefc(0x4)
    int m_PacketChecksumTime; // +0xf00(0x4)
    int m_CheckLifeTime; // +0xf04(0x4)
    UCHAR m_MoveOtherServer; // +0xf08(0x1)
    CHAR m_BossGoldDerconMapNumber; // +0xf09(0x1)
    UCHAR m_InWebzen; // +0xf0a(0x1)
    CHAR m_LastTeleportTime; // +0xf0b(0x1)
    UCHAR m_ClientHackLogCount; // +0xf0c(0x1)
    UCHAR m_bIsInMonsterHerd; // +0xf0d(0x1)
    UCHAR m_bIsMonsterAttackFirst; // +0xf0e(0x1)
    class MonsterHerd* m_lpMonsterHerd; // +0xf10(0x4)
    char NPggCSAuth[0x74]; // +0xf14(0x74) // class CCSAuth NPggCSAuth;
    ULONG m_NPggCheckSum; // +0xf88(0x4)
    ULONG m_NPggCheckSumSendTime; // +0xf8c(0x4)
    int fSkillFrustrumX[0x4]; // +0xf90(0x10)
    int fSkillFrustrumY[0x4]; // +0xfa0(0x10)
    UCHAR SkillHellFire2State; // +0xfb0(0x1)
    UCHAR SkillHellFire2Count; // +0xfb1(0x1)
    ULONG SkillHellFire2Time; // +0xfb4(0x4)
    UCHAR m_ReqWarehouseOpen; // +0xfb8(0x1)
    int m_NotAttackAreaCount; // +0xfbc(0x4)
    SHORT SetOpAddSkillAttack; // +0xfc0(0x2)
    SHORT SetOpAddExDamage; // +0xfc2(0x2)
    SHORT SetOpAddExDamageSuccessRate; // +0xfc4(0x2)
    SHORT SetOpAddCriticalDamage; // +0xfc6(0x2)
    SHORT SetOpAddCriticalDamageSuccessRate; // +0xfc8(0x2)
    SHORT SetOpIncAGValue; // +0xfca(0x2)
    SHORT SetOpAddDamage; // +0xfcc(0x2)
    SHORT SetOpAddMinAttackDamage; // +0xfce(0x2)
    SHORT SetOpAddMaxAttackDamage; // +0xfd0(0x2)
    SHORT SetOpAddAttackDamage; // +0xfd2(0x2)
    SHORT SetOpAddDefence; // +0xfd4(0x2)
    SHORT SetOpAddDefenceRate; // +0xfd6(0x2)
    SHORT SetOpAddMagicPower; // +0xfd8(0x2)
    UCHAR SetOpIgnoreDefense; // +0xfda(0x1)
    UCHAR SetOpDoubleDamage; // +0xfdb(0x1)
    UCHAR SetOpTwoHandSwordImproveDamage; // +0xfdc(0x1)
    UCHAR SetOpImproveSuccessAttackRate; // +0xfdd(0x1)
    UCHAR SetOpReflectionDamage; // +0xfde(0x1)
    UCHAR SetOpImproveSheldDefence; // +0xfdf(0x1)
    UCHAR SetOpDecreaseAG; // +0xfe0(0x1)
    UCHAR SetOpImproveItemDropRate; // +0xfe1(0x1)
    UCHAR IsFullSetItem; // +0xfe2(0x1)
    char DurMagicKeyChecker[0x12c]; // +0xfe4(0x12c)	// class TDurMagicKeyChecker DurMagicKeyChecker;
    USHORT SkillRecallParty_Time; // +0x1110(0x2)
    UCHAR SkillRecallParty_MapNumber; // +0x1112(0x1)
    UCHAR SkillRecallParty_X; // +0x1113(0x1)
    UCHAR SkillRecallParty_Y; // +0x1114(0x1)
    USHORT SkillAddCriticalDamageTime; // +0x1116(0x2)
    USHORT SkillAddCriticalDamage; // +0x1118(0x2)
    UCHAR bIsChaosMixCompleted; // +0x111a(0x1)
    UCHAR SkillLongSpearChange; // +0x111b(0x1)
    char SkillDelay[0x404]; // +0x111c(0x404)	//  class CSkillDelay SkillDelay;
    int iObjectSecTimer; // +0x1520(0x4)
    UCHAR m_bMapSvrMoveQuit; // +0x1524(0x1)
    UCHAR m_bMapSvrMoveReq; // +0x1525(0x1)
    ULONG m_dwMapSvrQuitTick; // +0x1528(0x4)
    SHORT m_sPrevMapSvrCode; // +0x152c(0x2)
    SHORT m_sDestMapNumber; // +0x152e(0x2)
    UCHAR m_btDestX; // +0x1530(0x1)
    UCHAR m_btDestY; // +0x1531(0x1)
    UCHAR m_btWeaponState; // +0x1532(0x1)
    int m_iWeaponUser; // +0x1534(0x4)
    UCHAR m_btKillCount; // +0x1538(0x1)
    int m_iSkillStunTime; // +0x153c(0x4)
    int m_iSkillBrandOfSkillTime; // +0x1540(0x4)
    int m_iSkillInvisibleTime; // +0x1544(0x4)
    int m_iSkillManaSwellTime; // +0x1548(0x4)
    int m_iSkillManaSwell; // +0x154c(0x4)
    int m_iAccumulatedDamage; // +0x1550(0x4)
    int m_iPotionBlessTime; // +0x1554(0x4)
    int m_iPotionSoulTime; // +0x1558(0x4)
    ULONG m_dwLastCheckTick; // +0x155c(0x4)
    int m_iAutoRecuperationTime; // +0x1560(0x4)
    int m_iSkillNPCHelpTime; // +0x1564(0x4)
    int m_iSkillNPCDefense; // +0x1568(0x4)
    int m_iSkillNPCAttack; // +0x156c(0x4)
	

	
};
typedef OBJECTSTRUCT* LPOBJ;
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#else
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

struct OBJECTSTRUCT // 0x158c
{
    int m_Index; // +0x0(0x4)
    int Connected; // +0x4(0x4)
    CHAR LoginMsgSnd; // +0x8(0x1)
    CHAR LoginMsgCount; // +0x9(0x1)
    CHAR CloseCount; // +0xa(0x1)
    CHAR CloseType; // +0xb(0x1)
    struct _PER_SOCKET_CONTEXT* PerSocketContext; // +0xc(0x4)
    unsigned int m_socket; // +0x10(0x4)
    CHAR Ip_addr[0x10]; // +0x14(0x10)
    int UserNumber; // +0x24(0x4)
    int DBNumber; // +0x28(0x4)
    UCHAR Magumsa; // +0x2c(0x1)
    ULONG AutoSaveTime; // +0x30(0x4)
    ULONG ConnectCheckTime; // +0x34(0x4)
    ULONG CheckTick; // +0x38(0x4)
    UCHAR CheckSpeedHack; // +0x3c(0x1)
    ULONG CheckTick2; // +0x40(0x4)
    UCHAR CheckTickCount; // +0x44(0x1)
    ULONG SaveTimeForStatics; // +0x48(0x4)
    int iPingTime; // +0x4c(0x4)
    UCHAR m_TimeCount; // +0x50(0x1)
    ULONG m_dwPKTimer; // +0x54(0x4)
    SHORT CheckSumTableNum; // +0x58(0x2)
    ULONG CheckSumTime; // +0x5c(0x4)
    USHORT Type; // +0x60(0x2)
    UCHAR Live; // +0x62(0x1)
    CHAR CharacterPos; // +0x63(0x1)
    CHAR AccountID[0xb]; // +0x64(0xb)
    CHAR Name[0xb]; // +0x6f(0xb)
    CHAR LastJoominNumber[0xe]; // +0x7a(0xe)
	SHORT Filter;SHORT Filter2;SHORT Filter3;
    BYTE comboSkill[0xc-2]; // +0x8c(0xc)
    USHORT Class; // +0x98(0x2)
    UCHAR DbClass; // +0x9a(0x1)
    UCHAR ChangeUP; // +0x9b(0x1)
    SHORT Level; // +0x9c(0x2)
    int LevelUpPoint; // +0xa0(0x4)
    ULONG Experience; // +0xa4(0x4)
    ULONG NextExp; // +0xa8(0x4)
    int Money; // +0xac(0x4)
    SHORT Strength; // +0xb0(0x2)
    SHORT Dexterity; // +0xb2(0x2)
    SHORT Vitality; // +0xb4(0x2)
    SHORT Energy; // +0xb6(0x2)
    float Life; // +0xb8(0x4)
    float MaxLife; // +0xbc(0x4)
    float FillLife; // +0xc0(0x4)
    float FillLifeMax; // +0xc4(0x4)
    float Mana; // +0xc8(0x4)
    float MaxMana; // +0xcc(0x4)
    USHORT Leadership; // +0xd0(0x2)
    USHORT AddLeadership; // +0xd2(0x2)
    USHORT ChatLitmitTime; // +0xd4(0x2)
    UCHAR ChatLimitTimeSec; // +0xd6(0x1)
    UCHAR FillLifeCount; // +0xd7(0x1)
    SHORT AddStrength; // +0xd8(0x2)
    SHORT AddDexterity; // +0xda(0x2)
    SHORT AddVitality; // +0xdc(0x2)
    SHORT AddEnergy; // +0xde(0x2)
    int BP; // +0xe0(0x4)
    int MaxBP; // +0xe4(0x4)
    int AddBP; // +0xe8(0x4)
    float VitalityToLife; // +0xec(0x4)
    float EnergyToMana; // +0xf0(0x4)
    CHAR m_PK_Count; // +0xf4(0x1)
    CHAR m_PK_Level; // +0xf5(0x1)
    int m_PK_Time; // +0xf8(0x4)
    SHORT X; // +0xfc(0x2)
    SHORT Y; // +0xfe(0x2)
    UCHAR Dir; // +0x100(0x1)
    UCHAR MapNumber; // +0x101(0x1)
    int AddLife; // +0x104(0x4)
    int AddMana; // +0x108(0x4)
    UCHAR DamageMinus; // +0x10c(0x1)
    UCHAR DamageReflect; // +0x10d(0x1)
    SHORT MonsterDieGetMoney; // +0x10e(0x2)
    UCHAR MonsterDieGetLife; // +0x110(0x1)
    UCHAR MonsterDieGetMana; // +0x111(0x1)
    UCHAR StartX; // +0x112(0x1)
    UCHAR StartY; // +0x113(0x1)
    SHORT m_OldX; // +0x114(0x2)
    SHORT m_OldY; // +0x116(0x2)
    SHORT TX; // +0x118(0x2)
    SHORT TY; // +0x11a(0x2)
    SHORT MTX; // +0x11c(0x2)
    SHORT MTY; // +0x11e(0x2)
    int PathCount; // +0x120(0x4)
    int PathCur; // +0x124(0x4)
    CHAR PathStartEnd; // +0x128(0x1)
    SHORT PathOri[0xf]; // +0x12a(0x1e)
    SHORT PathX[0xf]; // +0x148(0x1e)
    SHORT PathY[0xf]; // +0x166(0x1e)
    CHAR PathDir[0xf]; // +0x184(0xf)
    ULONG PathTime; // +0x194(0x4)
    CHAR m_MoveGateNumber; // +0x198(0x1)
    ULONG Authority; // +0x19c(0x4)
    ULONG AuthorityCode; // +0x1a0(0x4)
    ULONG Penalty; // +0x1a4(0x4)
    UCHAR m_cAccountItemBlock; // +0x1a8(0x1)
    LPVOID  m_ActState; // +0x1ac(0x4)
    UCHAR m_ActionNumber; // +0x1b0(0x1)
    ULONG m_State; // +0x1b4(0x4)
    CHAR m_StateSub; // +0x1b8(0x1)
    UCHAR m_Rest; // +0x1b9(0x1)
    CHAR m_ViewState; // +0x1ba(0x1)
    int m_ViewSkillState; // +0x1bc(0x4)
    ULONG m_LastMoveTime; // +0x1c0(0x4)
    ULONG m_LastAttackTime; // +0x1c4(0x4)
    UCHAR m_FriendServerOnline; // +0x1c8(0x1)
    int m_DetectSpeedHackTime; // +0x1cc(0x4)
    ULONG m_SumLastAttackTime; // +0x1d0(0x4)
    ULONG m_DetectCount; // +0x1d4(0x4)
    int m_DetectedHackKickCount; // +0x1d8(0x4)
    int m_SpeedHackPenalty; // +0x1dc(0x4)
    UCHAR m_AttackSpeedHackDetectedCount; // +0x1e0(0x1)
    ULONG m_PacketCheckTime; // +0x1e4(0x4)
    UCHAR m_ShopTime; // +0x1e8(0x1)
    ULONG m_TotalAttackTime; // +0x1ec(0x4)
    int m_TotalAttackCount; // +0x1f0(0x4)
    ULONG TeleportTime; // +0x1f4(0x4)
    CHAR Teleport; // +0x1f8(0x1)
    CHAR KillerType; // +0x1f9(0x1)
    CHAR DieRegen; // +0x1fa(0x1)
    CHAR RegenOk; // +0x1fb(0x1)
    UCHAR RegenMapNumber; // +0x1fc(0x1)
    UCHAR RegenMapX; // +0x1fd(0x1)
    UCHAR RegenMapY; // +0x1fe(0x1)
    ULONG RegenTime; // +0x200(0x4)
    ULONG MaxRegenTime; // +0x204(0x4)
    SHORT m_PosNum; // +0x208(0x2)
    ULONG LifeRefillTimer; // +0x20c(0x4)
    ULONG CurActionTime; // +0x210(0x4)
    ULONG NextActionTime; // +0x214(0x4)
    ULONG DelayActionTime; // +0x218(0x4)
    CHAR DelayLevel; // +0x21c(0x1)
    CHAR m_PoisonType; // +0x21d(0x1)
    CHAR m_IceType; // +0x21e(0x1)
    CHAR m_PoisonBeattackCount; // +0x21f(0x1)
    CHAR m_ColdBeattackCount; // +0x220(0x1)
    CHAR m_ImmuneToMagicCount; // +0x221(0x1)
    CHAR m_ImmuneToHarmCount; // +0x222(0x1)
    CHAR m_iMonsterBattleDelay; // +0x223(0x1)
    CHAR m_cKalimaGateExist; // +0x224(0x1)
    int m_iKalimaGateIndex; // +0x228(0x4)
    CHAR m_cKalimaGateEnterCount; // +0x22c(0x1)
    struct OBJECTSTRUCT* lpAttackObj; // +0x230(0x4)
    SHORT m_SkillNumber; // +0x234(0x2)
    ULONG m_SkillTime; // +0x238(0x4)
    UCHAR m_bAttackerKilled; // +0x23c(0x1)
    CHAR m_ManaFillCount; // +0x23d(0x1)
    CHAR m_LifeFillCount; // +0x23e(0x1)
    int SelfDefense[0x5]; // +0x240(0x14)
    ULONG SelfDefenseTime[0x5]; // +0x254(0x14)
    ULONG MySelfDefenseTime; // +0x268(0x4)
    CHAR m_Drink; // +0x26c(0x1)
    int m_SkillDefense; // +0x270(0x4)
    CHAR m_SkillDefenseTime; // +0x274(0x1)
    int m_SkillAttack; // +0x278(0x4)
    CHAR m_SkillAttackTime; // +0x27c(0x1)
    int m_SkillAttack2; // +0x280(0x4)
    CHAR m_SkillAttackTime2; // +0x284(0x1)
    int m_SkillAddLife; // +0x288(0x4)
    int m_SkillAddLifeTime; // +0x28c(0x4)
    int m_SkillHarden; // +0x290(0x4)
    int m_SkillHardenTime; // +0x294(0x4)
    int m_SkillMagumReduceDefense; // +0x298(0x4)
    int m_SkillMagumReduceDefenseTime; // +0x29c(0x4)
    int PartyNumber; // +0x2a0(0x4)
    int PartyTargetUser; // +0x2a4(0x4)
    int GuildNumber; // +0x2a8(0x4)
    _GUILD_INFO_STRUCT* lpGuild; // +0x2ac(0x4)
    CHAR GuildName[0xb]; // +0x2b0(0xb)
    int GuildStatus; // +0x2bc(0x4)
    int iGuildUnionTimeStamp; // +0x2c0(0x4)
    int m_RecallMon; // +0x2c4(0x4)
    int m_Change; // +0x2c8(0x4)
    SHORT TargetNumber; // +0x2cc(0x2)
    SHORT TargetShopNumber; // +0x2ce(0x2)
    SHORT ShopNumber; // +0x2d0(0x2)
    SHORT LastAttackerID; // +0x2d2(0x2)
    int m_AttackDamageMin; // +0x2d4(0x4)
    int m_AttackDamageMax; // +0x2d8(0x4)
    int m_MagicDamageMin; // +0x2dc(0x4)
    int m_MagicDamageMax; // +0x2e0(0x4)
    int m_AttackDamageLeft; // +0x2e4(0x4)
    int m_AttackDamageRight; // +0x2e8(0x4)
    int m_AttackDamageMaxLeft; // +0x2ec(0x4)
    int m_AttackDamageMinLeft; // +0x2f0(0x4)
    int m_AttackDamageMaxRight; // +0x2f4(0x4)
    int m_AttackDamageMinRight; // +0x2f8(0x4)
    int m_AttackRating; // +0x2fc(0x4)
    int m_AttackSpeed; // +0x300(0x4)
    int m_MagicSpeed; // +0x304(0x4)
    int m_Defense; // +0x308(0x4)
    int m_MagicDefense; // +0x30c(0x4)
    int m_SuccessfulBlocking; // +0x310(0x4)
    SHORT m_MoveSpeed; // +0x314(0x2)
    SHORT m_MoveRange; // +0x316(0x2)
    SHORT m_AttackRange; // +0x318(0x2)
    SHORT m_AttackType; // +0x31a(0x2)
    SHORT m_ViewRange; // +0x31c(0x2)
    SHORT m_Attribute; // +0x31e(0x2)
    SHORT m_ItemRate; // +0x320(0x2)
    SHORT m_MoneyRate; // +0x322(0x2)
    int m_CriticalDamage; // +0x324(0x4)
    int m_ExcelentDamage; // +0x328(0x4)
    class CMagicInf* m_lpMagicBack; // +0x32c(0x4)
    class CMagicInf* Magic; // +0x330(0x4)
    CHAR MagicCount; // +0x334(0x1)
    UCHAR UseMagicNumber; // +0x335(0x1)
    ULONG UseMagicTime; // +0x338(0x4)
    CHAR UseMagicCount; // +0x33c(0x1)
    SHORT OSAttackSerial; // +0x33e(0x2)
    UCHAR SASCount; // +0x340(0x1)
    ULONG SkillAttackTime; // +0x344(0x4)
    UCHAR CharSet[0xd]; // +0x348(0xd)
    UCHAR m_Resistance[0x7]; // +0x355(0x7)
    UCHAR m_AddResistance[0x7]; // +0x35c(0x7)
    int FrustrumX[0x4]; // +0x364(0x10)
    int FrustrumY[0x4]; // +0x374(0x10)
    BYTE VpPlayer[0x384]; // +0x384(0x384)
    BYTE VpPlayer2[0x384]; // +0x708(0x384)
    int VPCount; // +0xa8c(0x4)
    int VPCount2; // +0xa90(0x4)
    BYTE sHD[0x1e0]; // +0xa94(0x1e0)
    SHORT sHDCount; // +0xc74(0x2)
    struct tagInterfaceState m_IfState; // +0xc78(0x4)
    ULONG m_InterfaceTime; // +0xc7c(0x4)
    CITEM_STRUCT* pInventory; // +0xc80(0x4)
    UCHAR* pInventoryMap; // +0xc84(0x4)
    CHAR* pInventoryCount; // +0xc88(0x4)
    CHAR pTransaction; // +0xc8c(0x1)
    class CItem* Inventory1; // +0xc90(0x4)
    UCHAR* InventoryMap1; // +0xc94(0x4)
    CHAR InventoryCount1; // +0xc98(0x1)
    class CItem* Inventory2; // +0xc9c(0x4)
    UCHAR* InventoryMap2; // +0xca0(0x4)
    CHAR InventoryCount2; // +0xca4(0x1)
    class CItem* Trade; // +0xca8(0x4)
    UCHAR* TradeMap; // +0xcac(0x4)
    int TradeMoney; // +0xcb0(0x4)
    UCHAR TradeOk; // +0xcb4(0x1)
    CITEM_STRUCT* pWarehouse; // +0xcb8(0x4)
    UCHAR* pWarehouseMap; // +0xcbc(0x4)
    CHAR WarehouseCount; // +0xcc0(0x1)
    SHORT WarehousePW; // +0xcc2(0x2)
    UCHAR WarehouseLock; // +0xcc4(0x1)
    UCHAR WarehouseUnfailLock; // +0xcc5(0x1)
    int WarehouseMoney; // +0xcc8(0x4)
    int WarehouseSave; // +0xccc(0x4)
    class CItem* pChaosBox; // +0xcd0(0x4)
    UCHAR* pChaosBoxMap; // +0xcd4(0x4)
    int ChaosMoney; // +0xcd8(0x4)
    int ChaosSuccessRate; // +0xcdc(0x4)
    int ChaosLock; // +0xce0(0x4)
    ULONG m_Option; // +0xce4(0x4)
    int m_nEventScore; // +0xce8(0x4)
    int m_nEventExp; // +0xcec(0x4)
    int m_nEventMoney; // +0xcf0(0x4)
    UCHAR m_bDevilSquareIndex; // +0xcf4(0x1)
    UCHAR m_bDevilSquareAuth; // +0xcf5(0x1)
    CHAR m_cBloodCastleIndex; // +0xcf6(0x1)
    CHAR m_cBloodCastleSubIndex; // +0xcf7(0x1)
    int m_iBloodCastleEXP; // +0xcf8(0x4)
    CHAR m_cChaosCastleIndex; // +0xcfc(0x1)
    CHAR m_cChaosCastleSubIndex; // +0xcfd(0x1)
    int m_iChaosCastleBlowTime; // +0xd00(0x4)
    CHAR m_cKillUserCount; // +0xd04(0x1)
    CHAR m_cKillMonsterCount; // +0xd05(0x1)
    int m_iDuelUserReserved; // +0xd08(0x4)
    int m_iDuelUserRequested; // +0xd0c(0x4)
    int m_iDuelUser; // +0xd10(0x4)
    UCHAR m_btDuelScore; // +0xd14(0x1)
    int m_iDuelTickCount; // +0xd18(0x4)
    UCHAR m_bPShopOpen; // +0xd1c(0x1)
    UCHAR m_bPShopTransaction; // +0xd1d(0x1)
    UCHAR m_bPShopItemChange; // +0xd1e(0x1)
    UCHAR m_bPShopRedrawAbs; // +0xd1f(0x1)
    CHAR m_szPShopText[0x24]; // +0xd20(0x24)
    UCHAR m_bPShopWantDeal; // +0xd44(0x1)
    int m_iPShopDealerIndex; // +0xd48(0x4)
    CHAR m_szPShopDealerName[0xa]; // +0xd4c(0xa)
    struct _RTL_CRITICAL_SECTION m_critPShopTrade; // +0xd58(0x18)
    int m_iVpPShopPlayer[0x4b]; // +0xd70(0x12c)
    USHORT m_wVpPShopPlayerCount; // +0xe9c(0x2)
    UCHAR IsInBattleGround; // +0xe9e(0x1)
    UCHAR HaveWeaponInHand; // +0xe9f(0x1)
    SHORT EventChipCount; // +0xea0(0x2)
    int MutoNumber; // +0xea4(0x4)
    int UseEventServer; // +0xea8(0x4)
    UCHAR LoadWareHouseInfo; // +0xeac(0x1)
    int iStoneCount; // +0xeb0(0x4)
    UCHAR m_Quest[0x32]; // +0xeb4(0x32)
    UCHAR m_SendQuestInfo; // +0xee6(0x1)
    int m_SkyBossMonSheildLinkIndex; // +0xee8(0x4)
    int m_SkyBossMonSheild; // +0xeec(0x4)
    int m_SkyBossMonSheildTime; // +0xef0(0x4)
    int m_MaxLifePower; // +0xef4(0x4)
    int m_WizardSkillDefense; // +0xef8(0x4)
    int m_WizardSkillDefenseTime; // +0xefc(0x4)
    int m_PacketChecksumTime; // +0xf00(0x4)
    int m_CheckLifeTime; // +0xf04(0x4)
    UCHAR m_MoveOtherServer; // +0xf08(0x1)
    CHAR m_BossGoldDerconMapNumber; // +0xf09(0x1)
    UCHAR m_InWebzen; // +0xf0a(0x1)
    CHAR m_LastTeleportTime; // +0xf0b(0x1)
    UCHAR m_ClientHackLogCount; // +0xf0c(0x1)
    UCHAR m_bIsInMonsterHerd; // +0xf0d(0x1)
    UCHAR m_bIsMonsterAttackFirst; // +0xf0e(0x1)
    class MonsterHerd* m_lpMonsterHerd; // +0xf10(0x4)
    BYTE NPggCSAuth[0x74]; // +0xf14(0x74)
    ULONG m_NPggCheckSum; // +0xf88(0x4)
    ULONG m_NPggCheckSumSendTime; // +0xf8c(0x4)
    int fSkillFrustrumX[0x4]; // +0xf90(0x10)
    int fSkillFrustrumY[0x4]; // +0xfa0(0x10)
    UCHAR SkillHellFire2State; // +0xfb0(0x1)
    UCHAR SkillHellFire2Count; // +0xfb1(0x1)
    ULONG SkillHellFire2Time; // +0xfb4(0x4)
    UCHAR m_ReqWarehouseOpen; // +0xfb8(0x1)
    int m_NotAttackAreaCount; // +0xfbc(0x4)
    SHORT SetOpAddSkillAttack; // +0xfc0(0x2)
    SHORT SetOpAddExDamage; // +0xfc2(0x2)
    SHORT SetOpAddExDamageSuccessRate; // +0xfc4(0x2)
    SHORT SetOpAddCriticalDamage; // +0xfc6(0x2)
    SHORT SetOpAddCriticalDamageSuccessRate; // +0xfc8(0x2)
    SHORT SetOpIncAGValue; // +0xfca(0x2)
    SHORT SetOpAddDamage; // +0xfcc(0x2)
    SHORT SetOpAddMinAttackDamage; // +0xfce(0x2)
    SHORT SetOpAddMaxAttackDamage; // +0xfd0(0x2)
    SHORT SetOpAddAttackDamage; // +0xfd2(0x2)
    SHORT SetOpAddDefence; // +0xfd4(0x2)
    SHORT SetOpAddDefenceRate; // +0xfd6(0x2)
    SHORT SetOpAddMagicPower; // +0xfd8(0x2)
    UCHAR SetOpIgnoreDefense; // +0xfda(0x1)
    UCHAR SetOpDoubleDamage; // +0xfdb(0x1)
    UCHAR SetOpTwoHandSwordImproveDamage; // +0xfdc(0x1)
    UCHAR SetOpImproveSuccessAttackRate; // +0xfdd(0x1)
    UCHAR SetOpReflectionDamage; // +0xfde(0x1)
    UCHAR SetOpImproveSheldDefence; // +0xfdf(0x1)
    UCHAR SetOpDecreaseAG; // +0xfe0(0x1)
    UCHAR SetOpImproveItemDropRate; // +0xfe1(0x1)
    UCHAR IsFullSetItem; // +0xfe2(0x1)
    BYTE DurMagicKeyChecker[0x12c]; // +0xfe4(0x12c)
    USHORT SkillRecallParty_Time; // +0x1110(0x2)
    UCHAR SkillRecallParty_MapNumber; // +0x1112(0x1)
    UCHAR SkillRecallParty_X; // +0x1113(0x1)
    UCHAR SkillRecallParty_Y; // +0x1114(0x1)
    USHORT SkillAddCriticalDamageTime; // +0x1116(0x2)
    USHORT SkillAddCriticalDamage; // +0x1118(0x2)
    UCHAR bIsChaosMixCompleted; // +0x111a(0x1)
    UCHAR SkillLongSpearChange; // +0x111b(0x1)
    BYTE SkillDelay[0x404]; // +0x111c(0x404)
    int iObjectSecTimer; // +0x1520(0x4)
    UCHAR m_bMapSvrMoveQuit; // +0x1524(0x1)
    UCHAR m_bMapSvrMoveReq; // +0x1525(0x1)
    ULONG m_dwMapSvrQuitTick; // +0x1528(0x4)
    SHORT m_sPrevMapSvrCode; // +0x152c(0x2)
    SHORT m_sDestMapNumber; // +0x152e(0x2)
    UCHAR m_btDestX; // +0x1530(0x1)
    UCHAR m_btDestY; // +0x1531(0x1)
    UCHAR m_btCsNpcExistVal1; // +0x1534(0x1)
    UCHAR m_btCsNpcExistVal2; // +0x1535(0x1)
    UCHAR m_btCsNpcExistVal3; // +0x1536(0x1)
    UCHAR m_btCsNpcExistVal4; // +0x1537(0x1)
    int m_iCsNpcExistVal; // +0x1534(0x4)
    UCHAR m_btCsNpcType; // +0x1538(0x1)
    UCHAR m_btCsGateOpen; // +0x1539(0x1)
    int m_iCsGateLeverLinkIndex; // +0x153c(0x4)
    UCHAR m_btCsNpcDfLevel; // +0x1540(0x1)
    UCHAR m_btCsNpcRgLevel; // +0x1541(0x1)
    UCHAR m_btCsJoinSide; // +0x1542(0x1)
    UCHAR m_bCsGuildInvolved; // +0x1543(0x1)
    UCHAR m_btWeaponState; // +0x1544(0x1)
    int m_iWeaponUser; // +0x1548(0x4)
    UCHAR m_btKillCount; // +0x154c(0x1)
    int m_iSkillStunTime; // +0x1550(0x4)
    int m_iSkillBrandOfSkillTime; // +0x1554(0x4)
    int m_iSkillInvisibleTime; // +0x1558(0x4)
    int m_iSkillManaSwellTime; // +0x155c(0x4)
    int m_iSkillManaSwell; // +0x1560(0x4)
    int m_iAccumulatedDamage; // +0x1564(0x4)
    int m_iPotionBlessTime; // +0x1568(0x4)
    int m_iPotionSoulTime; // +0x156c(0x4)
    UCHAR m_btLifeStoneCount; // +0x1570(0x1)
    UCHAR m_btCreationState; // +0x1571(0x1)
    int m_iCreatedActivationTime; // +0x1574(0x4)
    ULONG m_dwLastCheckTick; // +0x1578(0x4)
    int m_iAutoRecuperationTime; // +0x157c(0x4)
    int m_iSkillNPCHelpTime; // +0x1580(0x4)
    int m_iSkillNPCDefense; // +0x1584(0x4)

}; typedef OBJECTSTRUCT* LPOBJ;
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#endif /* GS_99_60T */
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

int		gObjGetIndexByName	(char* Name);
int		gObjGetIndexByAccountId(char * szAcccountId);
bool	gObjIsGameMaster	(int aIndex);
bool	gObjIsGameSI		(int aIndex);
int		gObjGetMapLevel		(int Map, int Class);
LPCSTR	gObjGetClassName	(int aIndex);
LPCSTR	gObjGetClassNameByID(int ID);
LPCSTR	GetMapName			(int aIndex);
LPCSTR	GetMapNameByID		(int ID);
LPCSTR	GetMapNameHeByID	(int ID);
BYTE	LevelSmallConvert	(int level);
bool	gObjIsAccontConnect	(int aIndex, char * szAccountID);
bool	gObjIsAccontConnect	(char * szAccountID);
void	gObjCastRegen		(int aIndex, int gt);
bool	isMoveNGate			(int gt);
void	GCJoinResult		(BYTE result, int aIndex);
BOOL	gObjIsConnected		(int Index);
void	PHeadSubSetB		(LPBYTE lpBuf, BYTE head, BYTE sub, int size);
void	FireworkOnTheScreen (int aIndex);
bool	gObjCheckUserResets (int aIndex, int Reset);
bool	gObjCheckUserResets (int aIndex, int Reset, int RResets);
bool	gObjCheckUserResetsGap (int aIndex, int tIndex, int ResetGap, int minResets, bool difClass);
bool	PacketCheckTime		(OBJECTSTRUCT * lpObj);
bool	gObjFixInventoryPointer	(int aIndex);
void	gObjSetInventory1Pointer(OBJECTSTRUCT * lpObj);
bool	gObjIsFreeSlotForItem(int aIndex, CItem item);
BYTE	gObjShopBuyInventoryInsertItem(int aIndex, CItem item);

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

void	PHeadSetB			(LPBYTE lpBuf, BYTE head, int size);
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
extern OBJECTSTRUCT * gObj;
extern DWORD g_dwDLBestAttack;
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#endif /* USER_H */
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------